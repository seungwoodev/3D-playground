<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>cannon.js + three.js - voxel shooter</title>
    <link rel="stylesheet" href="css/style.css" type="text/css" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <style>
      #instructions {
        position: fixed;
        left: 0;
        top: 0;

        width: 100%;
        height: 100%;

        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;

        background-color: rgba(0, 0, 0, 0.5);
        color: #ffffff;
        text-align: center;

        cursor: pointer;
      }
      #instructions span {
        font-size: 40px;
      }
    </style>
    <script type="module">
      import { addTitle, addSourceButton } from './js/dom-utils.js'

      addTitle()
      addSourceButton()
    </script>
  </head>
  <body>
    <div id="instructions">
      <span>Click to play</span>
      <br />
      (W,A,S,D = Move, SPACE = Jump, MOUSE = Look, CLICK = Shoot)
    </div>
    <script src="js/simplex-noise.js"></script>

    <script type="module">
      import * as CANNON from './dist/cannon-es.js'
      import * as THREE from 'https://unpkg.com/three@0.122.0/build/three.module.js'
      import Stats from 'https://unpkg.com/three@0.122.0/examples/jsm/libs/stats.module.js'
      import { PointerLockControlsCannon } from './js/PointerLockControlsCannon.js'
      import { VoxelLandscape } from './js/VoxelLandscape.js'

      /**
       * Example construction of a voxel world and player.
       */

      // three.js variables
      let camera, scene, renderer, stats
      let material
      let floor, music, audioBall
      var mesh;
      var ambientLight;
      var audioPointLight;
      var spotLight;

      // To be synced
      var meshes = [];
      var bodies = [];

      // cannon.js variables
      let world
      let controls
      const timeStep = 1 / 60
      let lastCallTime = performance.now() / 1000
      let sphereShape
      let musicShape
      let sphereBody
      let musicBody
      let physicsMaterial
      let voxels

      const balls = []
      const ballMeshes = []
      const boxes = []
      const boxMeshes = []

      // Number of voxels
      const nx = 50
      const ny = 8
      const nz = 50

      // Scale of voxels
      const sx = 0.5
      const sy = 0.5
      const sz = 0.5

      // music audio
      const listener = new THREE.AudioListener();
      var sound = new THREE.Audio( listener );
      const audioLoader = new THREE.AudioLoader();

      var noise;
      var context;
      var src;
      var analyser;
      var bufferLength;
      var dataArray;

      var offline;
      var bufferSource;
      var scp;
      var freqData;
      var audio;


      var lowerHalfArray;
      var upperHalfArray;

      var overallAvg;
      var lowerMax;
      var lowerAvg;
      var upperMax;
      var upperAvg;

      var lowerMaxFr;
      var lowerAvgFr;
      var upperMaxFr;
      var upperAvgFr;

      var isMusicPlayed = false;
      var isAnalyser = false;


      initThree()
      initCannon()
      initPointerLock()
      animate()

      function initThree() {
        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)

        // Scene
        scene = new THREE.Scene()
        scene.fog = new THREE.Fog(0x000000, 0, 500)

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.setClearColor(scene.fog.color)

        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.PCFSoftShadowMap

        document.body.appendChild(renderer.domElement)


        // Stats.js
        stats = new Stats()
        document.body.appendChild(stats.dom)

        // Lights
        ambientLight = new THREE.AmbientLight(0xffffff, 0.2)
        ambientLight.name = "ambientLight"
        scene.add(ambientLight)

        var ambientLight2 = new THREE.AmbientLight(0xaaaaaa);
        scene.add(ambientLight2);

      

        // Generic material
        material = new THREE.MeshLambertMaterial({ color: 0xdddddd })

        // Floor
        const floorGeometry = new THREE.PlaneBufferGeometry(300, 300, 50, 50)
        floorGeometry.rotateX(-Math.PI / 2)
        floor = new THREE.Mesh(floorGeometry, material)
        floor.receiveShadow = true
        scene.add(floor)

        // Music text object
        const loader = new THREE.FontLoader();

        loader.load('https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json', (font) => {
          const text = 'Music';  

          const musicGeometry = new THREE.TextGeometry(text, {
            font: font,
            size: 3,  

            height: 0.2,  

            curveSegments: 12,  

            bevelEnabled: true,  
            bevelThickness: 0.15,  

            bevelSize: 0.3,  

            bevelSegments: 5,  

          });
          const musicMaterial = new THREE.MeshPhongMaterial({ color: 0x97df5e });
          music = new THREE.Mesh(musicGeometry, musicMaterial);
          music.position.x = 0
          music.position.y = 2
          music.position.z = -30
          scene.add(music);
          console.log('music position x y z', music.position.x, music.position.y, music.position.z)

        });

        // // position test box object
        // const phongMaterial = new THREE.MeshPhongMaterial()
        // const width =  11.5;  
        // const height = 4.0;  
        // const depth = 1.0;  
        // const testGeometry = new THREE.BoxGeometry(width/2, height/2, depth/2);
        // const testBox = new THREE.Mesh(testGeometry, phongMaterial);

        // testBox.position.x = 5;
        // testBox.position.y = 3.5;
        // testBox.position.z = -30;
        // scene.add(testBox);

        // audio visualizer
        var icosahedronGeometry = new THREE.IcosahedronGeometry(10, 4);
        var lambertMaterial = new THREE.MeshLambertMaterial({
            color: 0xff00ee,
            wireframe: true
        });

        audioBall = new THREE.Mesh(icosahedronGeometry, lambertMaterial);
        audioBall.position.set(0, 15, 0);
        scene.add(audioBall);

        spotLight = new THREE.SpotLight(0xffffff, 0.2);
        spotLight.position.set(-10, 70, 20);
        spotLight.lookAt(audioBall);
        spotLight.castShadow = true;
        spotLight.name = "spotLight";
        scene.add(spotLight);
        
        window.addEventListener('resize', onWindowResize)
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      }



      function initCannon() {
        // Setup world
        world = new CANNON.World()

        // Tweak contact properties.
        // Contact stiffness - use to make softer/harder contacts
        world.defaultContactMaterial.contactEquationStiffness = 1e9

        // Stabilization time in number of timesteps
        world.defaultContactMaterial.contactEquationRelaxation = 4

        const solver = new CANNON.GSSolver()
        solver.iterations = 7
        solver.tolerance = 0.1
        world.solver = new CANNON.SplitSolver(solver)
        // use this to test non-split solver
        // world.solver = solver

        world.gravity.set(0, -20, 0)

        world.broadphase.useBoundingBoxes = true

        // Create a slippery material (friction coefficient = 0.0)
        physicsMaterial = new CANNON.Material('physics')
        const physics_physics = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, {
          friction: 0.3,
          restitution: 0.3,
        })

        // We must add the contact materials to the world
        world.addContactMaterial(physics_physics)

        // Create the user collision sphere
        const radius = 1.3
        sphereShape = new CANNON.Sphere(radius)
        sphereBody = new CANNON.Body({ mass: 5, material: physicsMaterial })
        sphereBody.addShape(sphereShape)
        sphereBody.position.set(nx * sx * 0.5, ny * sy + radius * 2, nz * sz * 0.5)
        sphereBody.linearDamping = 0.9

        world.addBody(sphereBody)
        console.log("user start position", nx * sx * 0.5, ny * sy + radius * 2, nz * sz * 0.5);


        // Create the ground plane
        const groundShape = new CANNON.Plane()
        const groundBody = new CANNON.Body({ mass: 0, material: physicsMaterial })
        groundBody.addShape(groundShape)
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0)
        world.addBody(groundBody)


        // Music object apply physic
        const width =  11.5;  
        const height = 4.0;  
        const depth = 1.0;
        const musicShape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2))
        const musicBody = new CANNON.Body({ mass: 0 })
        const musicQuaternion = new CANNON.Quaternion();
        musicQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), 0)
        musicBody.addShape(musicShape, new CANNON.Vec3(), musicQuaternion)
        musicBody.position.x = 5
        musicBody.position.y = 3.5
        musicBody.position.z = -30

        // collide music
        musicBody.addEventListener('collide', (event) => {
          audioLoader.load( './music/방탄소년단_Dynamite.mp3', function( buffer ) {
            sound.setBuffer( buffer );
            console.log('sound1', typeof sound);
            sound.setLoop( true );
            sound.setVolume( 0.5 );
            sound.play();
            isMusicPlayed = true;
            console.log('play');
            console.log('isMusicPlayed', isMusicPlayed);
            // audio visualizer
            // initialise simplex noise instance
            noise = new SimplexNoise();
            console.log('context start');
            // context = new (window.AudioContext || window.webkitAudioContext)();
            // src = context.createBufferSource();
            // src.buffer = sound.buffer;
            // console.log('sound buffer', sound.buffer);
            // console.log('src buffer', src.buffer);
            // analyser = await context.createAnalyser();
            // analyser.minDecibels = -100;
            // analyser.maxDecibels = -30;
            // src.connect(analyser);
            // await analyser.connect(context.destination);
            // analyser.fftSize = 512;
            // bufferLength = analyser.frequencyBinCount;
            // console.log('frequencyBinCount', bufferLength);
            // dataArray = new Uint8Array(bufferLength);
            // // dataArray = new Float32Array(bufferLength);
            // console.log('analyser', analyser);
            // console.log('sound0', typeof sound);
            isAnalyser = true;

            offline = new OfflineAudioContext(2, buffer.length ,44100);
            bufferSource = offline.createBufferSource();
            bufferSource.buffer = buffer;

            analyser = offline.createAnalyser();
            scp = offline.createScriptProcessor(256, 0, 1);

            bufferSource.connect(analyser);
            scp.connect(offline.destination); // this is necessary for the script processor to start

            freqData = new Uint8Array(analyser.frequencyBinCount);
            scp.onaudioprocess = function(){
              analyser.getByteFrequencyData(freqData);
              // console.log(freqData);
            };
            bufferSource.start(0);
            offline.oncomplete = function(e){
              isMusicPlayed = false;
              // console.log('analysed');
            };
            offline.startRendering();

          }); 

        });


        world.addBody(musicBody)


        // Voxels
        voxels = new VoxelLandscape(world, nx, ny, nz, sx, sy, sz)

        for (let i = 0; i < nx; i++) {
          for (let j = 0; j < ny; j++) {
            for (let k = 0; k < nz; k++) {
              let filled = true

              // Insert map constructing logic here
              if (Math.sin(i * 0.1) * Math.sin(k * 0.1) < (j / ny) * 2 - 1) {
                filled = false
              }

              voxels.setFilled(i, j, k, filled)
            }
          }
        }

        voxels.update()

        console.log(`${voxels.boxes.length} voxel physics bodies`)

        // Voxel meshes
        for (let i = 0; i < voxels.boxes.length; i++) {
          const box = voxels.boxes[i]
          const voxelGeometry = new THREE.BoxBufferGeometry(voxels.sx * box.nx, voxels.sy * box.ny, voxels.sz * box.nz)
          const voxelMesh = new THREE.Mesh(voxelGeometry, material)
          voxelMesh.castShadow = true
          voxelMesh.receiveShadow = true
          boxMeshes.push(voxelMesh)
          scene.add(voxelMesh)
        }

        // The shooting balls
        const shootVelocity = 15
        const ballShape = new CANNON.Sphere(0.2)
        const ballGeometry = new THREE.SphereBufferGeometry(ballShape.radius, 32, 32)

        // Returns a vector pointing the the diretion the camera is at
        function getShootDirection() {
          const vector = new THREE.Vector3(0, 0, 1)
          vector.unproject(camera)
          const ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize())
          return ray.direction
        }

        window.addEventListener('click', (event) => {
          if (!controls.enabled) {
            return
          }

          const ballBody = new CANNON.Body({ mass: 1 })
          ballBody.addShape(ballShape)
          const ballMesh = new THREE.Mesh(ballGeometry, material)

          ballMesh.castShadow = true
          ballMesh.receiveShadow = true

          world.addBody(ballBody)
          scene.add(ballMesh)
          balls.push(ballBody)
          ballMeshes.push(ballMesh)

          const shootDirection = getShootDirection()
          ballBody.velocity.set(
            shootDirection.x * shootVelocity,
            shootDirection.y * shootVelocity,
            shootDirection.z * shootVelocity
          )

          // Move the ball outside the player sphere
          const x = sphereBody.position.x + shootDirection.x * (sphereShape.radius * 1.02 + ballShape.radius)
          const y = sphereBody.position.y + shootDirection.y * (sphereShape.radius * 1.02 + ballShape.radius)
          const z = sphereBody.position.z + shootDirection.z * (sphereShape.radius * 1.02 + ballShape.radius)
          ballBody.position.set(x, y, z)
          ballMesh.position.copy(ballBody.position)
        })
      }

    

      function initPointerLock() {
        controls = new PointerLockControlsCannon(camera, sphereBody)
        scene.add(controls.getObject())

        instructions.addEventListener('click', () => {
          controls.lock()
        })

        controls.addEventListener('lock', () => {
          controls.enabled = true
          instructions.style.display = 'none'
        })

        controls.addEventListener('unlock', () => {
          controls.enabled = false
          instructions.style.display = null
        })
      }
      
      function removeEntity(object) {
            var selectedObject = scene.getObjectByName(object.name);
            scene.remove( selectedObject );
          }
          
      function makeRoughBall(mesh, bassFr, treFr) {
        mesh.geometry.vertices.forEach(function (vertex, i) {
            var offset = mesh.geometry.parameters.radius;
            var amp = 7;
            var time = window.performance.now();
            vertex.normalize();
            var rf = 0.00001;
            var distance = (offset + bassFr ) + noise.noise3D(vertex.x + time *rf*7, vertex.y +  time*rf*8, vertex.z + time*rf*9) * amp * treFr;
            vertex.multiplyScalar(distance);
        });
        mesh.geometry.verticesNeedUpdate = true;
        mesh.geometry.normalsNeedUpdate = true;
        mesh.geometry.computeVertexNormals();
        mesh.geometry.computeFaceNormals();
      }

      //some helper functions for audio visualizer here
      function fractionate(val, minVal, maxVal) {
          return (val - minVal)/(maxVal - minVal);
      }

      function modulate(val, minVal, maxVal, outMin, outMax) {
          var fr = fractionate(val, minVal, maxVal);
          var delta = outMax - outMin;
          return outMin + (fr * delta);
      }

      function avg(arr){
          var total = arr.reduce(function(sum, b) { return sum + b; });
          return (total / arr.length);
      }

      function max(arr){
          return arr.reduce(function(a, b){ return Math.max(a, b); })
      }


      function animate() {

        const time = performance.now() / 1000
        const dt = time - lastCallTime
        lastCallTime = time

        if (controls.enabled) {
          world.step(timeStep, dt)

          // Update ball positions
          for (let i = 0; i < balls.length; i++) {
            ballMeshes[i].position.copy(balls[i].position)
            ballMeshes[i].quaternion.copy(balls[i].quaternion)
          }

          // Update box positions
          for (let i = 0; i < voxels.boxes.length; i++) {
            boxMeshes[i].position.copy(voxels.boxes[i].position)
            boxMeshes[i].quaternion.copy(voxels.boxes[i].quaternion)
          }


          
          if(isMusicPlayed && isAnalyser){

            // Update light
            removeEntity(ambientLight)
            ambientLight = new THREE.AmbientLight(0xffffff*Math.random(), 0.2)
            ambientLight.name = "ambientLight"
            scene.add(ambientLight)

            removeEntity(spotLight);
            spotLight = new THREE.SpotLight(0xffffff*Math.random(), 0.2);
            spotLight.position.set(-10, 70, 20);
            spotLight.lookAt(audioBall);
            spotLight.castShadow = true;
            spotLight.name = "spotLight";
            scene.add(spotLight);

            // audio visualizer
            // console.log('analyser2', analyser);
            analyser.getByteFrequencyData(freqData);
            // console.log('dataArray', dataArray);

            lowerHalfArray = freqData.slice(0, (freqData.length/2) - 1);
            upperHalfArray = freqData.slice((freqData.length/2) - 1, freqData.length - 1);

            overallAvg = avg(freqData);
            lowerMax = max(lowerHalfArray);
            lowerAvg = avg(lowerHalfArray);
            upperMax = max(upperHalfArray);
            upperAvg = avg(upperHalfArray);

            lowerMaxFr = lowerMax / lowerHalfArray.length;
            lowerAvgFr = lowerAvg / lowerHalfArray.length;
            upperMaxFr = upperMax / upperHalfArray.length;
            upperAvgFr = upperAvg / upperHalfArray.length;
            makeRoughBall(audioBall, modulate(Math.pow(lowerMaxFr, 0.8), 0, 1, 0, 8), modulate(upperAvgFr, 0, 1, 0, 4));
          }
          
        }


        controls.update(dt)
        renderer.render(scene, camera)
        requestAnimationFrame(animate)
        stats.update()

      }
    </script>
  </body>
</html>