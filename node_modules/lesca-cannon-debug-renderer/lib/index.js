"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var THREE = _interopRequireWildcard(require("three"));

var CANNON = _interopRequireWildcard(require("cannon"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var CannonDebugRenderer = /*#__PURE__*/function () {
  function CannonDebugRenderer(scene, world) {
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0x00ff00;

    _classCallCheck(this, CannonDebugRenderer);

    this.scene = scene;
    this.world = world;
    this._meshes = [];
    this._material = new THREE.MeshBasicMaterial({
      color: color,
      wireframe: true,
      wireframeLinewidth: width
    });
    this._sphereGeometry = new THREE.SphereGeometry(1);
    this._boxGeometry = new THREE.BoxGeometry(1, 1, 1);
    this._planeGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
    this._cylinderGeometry = new THREE.CylinderGeometry(1, 1, 10, 10);
    this.tmpVec0 = new CANNON.Vec3();
    this.tmpVec1 = new CANNON.Vec3();
    this.tmpVec2 = new CANNON.Vec3();
    this.tmpQuat0 = new CANNON.Vec3();
  }

  _createClass(CannonDebugRenderer, [{
    key: "update",
    value: function update() {
      var bodies = this.world.bodies;
      var meshes = this._meshes;
      var shapeWorldPosition = this.tmpVec0;
      var shapeWorldQuaternion = this.tmpQuat0;
      var meshIndex = 0;

      for (var i = 0; i !== bodies.length; i++) {
        var body = bodies[i];

        for (var j = 0; j !== body.shapes.length; j++) {
          var shape = body.shapes[j];

          this._updateMesh(meshIndex, body, shape);

          var mesh = meshes[meshIndex];

          if (mesh) {
            body.quaternion.vmult(body.shapeOffsets[j], shapeWorldPosition);
            body.position.vadd(shapeWorldPosition, shapeWorldPosition);
            body.quaternion.mult(body.shapeOrientations[j], shapeWorldQuaternion);
            mesh.position.copy(shapeWorldPosition);
            mesh.quaternion.copy(shapeWorldQuaternion);
          }

          meshIndex++;
        }
      }

      for (var i = meshIndex; i < meshes.length; i++) {
        var mesh = meshes[i];

        if (mesh) {
          this.scene.remove(mesh);
        }
      }

      meshes.length = meshIndex;
    }
  }, {
    key: "_updateMesh",
    value: function _updateMesh(index, _body, shape) {
      var mesh = this._meshes[index];

      if (!this._typeMatch(mesh, shape)) {
        if (mesh) {
          this.scene.remove(mesh);
        }

        mesh = this._meshes[index] = this._createMesh(shape);
      }

      this._scaleMesh(mesh, shape);
    }
  }, {
    key: "_typeMatch",
    value: function _typeMatch(mesh, shape) {
      if (!mesh) {
        return false;
      }

      var geo = mesh.geometry;
      return geo instanceof THREE.SphereGeometry && shape instanceof CANNON.Sphere || geo instanceof THREE.BoxGeometry && shape instanceof CANNON.Box || geo instanceof THREE.PlaneGeometry && shape instanceof CANNON.Plane || geo.id === shape.geometryId && shape instanceof CANNON.ConvexPolyhedron || geo.id === shape.geometryId && shape instanceof CANNON.Trimesh || geo.id === shape.geometryId && shape instanceof CANNON.Heightfield;
    }
  }, {
    key: "_createMesh",
    value: function _createMesh(shape) {
      var mesh;
      var material = this._material;

      switch (shape.type) {
        case CANNON.Shape.types.SPHERE:
          mesh = new THREE.Mesh(this._sphereGeometry, material);
          break;

        case CANNON.Shape.types.BOX:
          mesh = new THREE.Mesh(this._boxGeometry, material);
          break;

        case CANNON.Shape.types.PLANE:
          mesh = new THREE.Mesh(this._planeGeometry, material);
          break;

        case CANNON.Shape.types.CONVEXPOLYHEDRON:
          var _debuger = shape._debuger;

          var _debuger2 = _slicedToArray(_debuger, 4),
              radiusTop = _debuger2[0],
              radiusBottom = _debuger2[1],
              height = _debuger2[2],
              radialSegments = _debuger2[3];

          var geo = new THREE.CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments);
          mesh = new THREE.Mesh(geo, material);
          break;

        case CANNON.Shape.types.TRIMESH:
          var geometry = new THREE.Geometry();
          var v0 = this.tmpVec0;
          var v1 = this.tmpVec1;
          var v2 = this.tmpVec2;

          for (var i = 0; i < shape.indices.length / 3; i++) {
            shape.getTriangleVertices(i, v0, v1, v2);
            geometry.vertices.push(new THREE.Vector3(v0.x, v0.y, v0.z), new THREE.Vector3(v1.x, v1.y, v1.z), new THREE.Vector3(v2.x, v2.y, v2.z));
            var j = geometry.vertices.length - 3;
            geometry.faces.push(new THREE.Face3(j, j + 1, j + 2));
          }

          geometry.computeBoundingSphere();
          geometry.computeFaceNormals();
          mesh = new THREE.Mesh(geometry, material);
          shape.geometryId = geometry.id;
          break;

        case CANNON.Shape.types.HEIGHTFIELD:
          var geometry = new THREE.Geometry();
          var v0 = this.tmpVec0;
          var v1 = this.tmpVec1;
          var v2 = this.tmpVec2;

          for (var xi = 0; xi < shape.data.length - 1; xi++) {
            for (var yi = 0; yi < shape.data[xi].length - 1; yi++) {
              for (var k = 0; k < 2; k++) {
                shape.getConvexTrianglePillar(xi, yi, k === 0);
                v0.copy(shape.pillarConvex.vertices[0]);
                v1.copy(shape.pillarConvex.vertices[1]);
                v2.copy(shape.pillarConvex.vertices[2]);
                v0.vadd(shape.pillarOffset, v0);
                v1.vadd(shape.pillarOffset, v1);
                v2.vadd(shape.pillarOffset, v2);
                geometry.vertices.push(new THREE.Vector3(v0.x, v0.y, v0.z), new THREE.Vector3(v1.x, v1.y, v1.z), new THREE.Vector3(v2.x, v2.y, v2.z));
                var i = geometry.vertices.length - 3;
                geometry.faces.push(new THREE.Face3(i, i + 1, i + 2));
              }
            }
          }

          geometry.computeBoundingSphere();
          geometry.computeFaceNormals();
          mesh = new THREE.Mesh(geometry, material);
          shape.geometryId = geometry.id;
          break;
      }

      if (mesh) {
        this.scene.add(mesh);
      }

      return mesh;
    }
  }, {
    key: "show",
    value: function show() {
      var _this = this;

      this._meshes.forEach(function (e) {
        _this.scene.add(e);
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this2 = this;

      this._meshes.forEach(function (e) {
        _this2.scene.remove(e);
      });
    }
  }, {
    key: "_scaleMesh",
    value: function _scaleMesh(mesh, shape) {
      switch (shape.type) {
        case CANNON.Shape.types.SPHERE:
          var radius = shape.radius;
          mesh.scale.set(radius, radius, radius);
          break;

        case CANNON.Shape.types.BOX:
          mesh.scale.copy(shape.halfExtents);
          mesh.scale.multiplyScalar(2);
          break;

        case CANNON.Shape.types.CONVEXPOLYHEDRON:
          mesh.scale.set(1, 1, 1);
          break;

        case CANNON.Shape.types.TRIMESH:
          mesh.scale.copy(shape.scale);
          break;

        case CANNON.Shape.types.HEIGHTFIELD:
          mesh.scale.set(1, 1, 1);
          break;
      }
    }
  }]);

  return CannonDebugRenderer;
}();

exports["default"] = CannonDebugRenderer;